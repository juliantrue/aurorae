generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// -----------------------------
// RITES AND VERSIONS
// -----------------------------
model Rite {
  id          Int           @id @default(autoincrement())
  name        String        @unique // e.g. "Roman", "Ambrosian"
  description String?
  versions    RiteVersion[]
}

model RiteVersion {
  id          Int       @id @default(autoincrement())
  slug        String    @unique // e.g. "rom1962", "rom1970", "rom2002"
  name        String
  promulgated DateTime? // promulgation date if known
  notes       String?

  riteId Int
  rite   Rite @relation(fields: [riteId], references: [id])

  // Self-relation for inheritance
  parentId Int?
  parent   RiteVersion?  @relation("RiteVersionParent", fields: [parentId], references: [id])
  children RiteVersion[] @relation("RiteVersionParent")

  movableFeasts          MovableFeast[]
  fixedFeasts            FixedFeast[]
  seasonalDays           SeasonalDay[]
  season                 Season[]
  rank                   Rank[]
  conflictResolutionRule ConflictResolutionRule[]
}

// ----------------------------------------------------------
// CALENDAR
// ----------------------------------------------------------
model CalendarLocale {
  id    Int           @id @default(autoincrement())
  name  String        @unique
  scope CalendarScope

  MovableFeast MovableFeast[]
  FixedFeast   FixedFeast[]
}

enum CalendarScope {
  UNIVERSAL
  NATIONAL
  DIOCESAN
  RELIGIOUS_ORDER
  LOCAL
}

model Rank {
  id          Int     @id @default(autoincrement())
  key         String // e.g., "sollemnitas", "festum duplex majus"
  name        String
  precedence  Int // numeric hierarchy, e.g., 1=highest
  description String?

  riteVersionId Int
  riteVersion   RiteVersion @relation(fields: [riteVersionId], references: [id])

  movableFeast           MovableFeast[]
  fixedFeast             FixedFeast[]
  seasonalDay            SeasonalDay[]
  conflictResolutionRule ConflictResolutionRule[]

  @@unique([key, riteVersionId])
}

model OnConflictTransferDefinition {
  id               Int          @id @default(autoincrement())
  transferKind     TransferKind
  offsetFromEaster Int?
  fixedYear        Int?
  fixedMonth       Int?
  fixedDay         Int?
}

enum TransferKind {
  TO_MOVEABLE
  TO_FIXED
}

model ConflictResolutionRule {
  id         Int            @id @default(autoincrement())
  onConflict ConflictAction
  notes      String?
  condition  String? // e.g. "if falls during Holy Week or Easter Octave"
  transferTo String? // e.g. "Monday after 2nd Sunday of Easter"

  riteVersionId  Int
  riteVersion    RiteVersion   @relation(fields: [riteVersionId], references: [id])
  rankId         Int?
  rank           Rank?         @relation(fields: [rankId], references: [id])
  movableFeastId Int?
  movableFeast   MovableFeast? @relation(fields: [movableFeastId], references: [id])
  fixedFeastId   Int?
  fixedFeast     FixedFeast?   @relation(fields: [fixedFeastId], references: [id])
}

enum ConflictAction {
  OMIT // Celebration dropped this year
  OPTIONAL // May be observed in part (e.g., local option)
  COMMEMORATE // Mentioned liturgically, not as full feast
  TRANSFER // Moved to a new date
}

model MovableFeast {
  id               Int     @id @default(autoincrement())
  key              String  @unique
  name             String
  yearNumber       Int
  offsetFromEaster Int
  description      String?

  riteVersionId Int
  riteVersion   RiteVersion    @relation(fields: [riteVersionId], references: [id])
  localeId      Int
  locale        CalendarLocale @relation(fields: [localeId], references: [id])
  rankId        Int
  rank          Rank           @relation(fields: [rankId], references: [id])

  // If moveable feast WERE to be transferred due to a conflict this field would be
  // set to point at the originally schedulled feast day. The resolved will follow 
  // this link to compute whether or not the feast WAS ACTUALLY translated
  // Movable --> Movable: (Hypothetical, very rare)
  rescheduledFromId Int?
  rescheduledFrom   MovableFeast?  @relation("RescheduledLink", fields: [rescheduledFromId], references: [id])
  rescheduledTo     MovableFeast[] @relation("RescheduledLink")

  // Optional cross-type link if a movable feast transfers to a fixedFeast definition
  // Movable --> Fixed. eg. St Joseph (if impeded in Holy Week → after Easter)I can't find an example of this existing, but we'll create the model anyway
  rescheduledToFixedId     Int?
  rescheduledToFixed       FixedFeast?  @relation("RescheduledToFixed", fields: [rescheduledToFixedId], references: [id])
  rescheduledToFixedFeasts FixedFeast[] @relation("RescheduleToMovable")

  horae                  Hora[]
  missae                 Missa[]
  conflictResolutionRule ConflictResolutionRule[]

  @@unique([key, riteVersionId])
}

model FixedFeast {
  id          Int     @id @default(autoincrement())
  key         String  @unique
  name        String
  yearNumber  Int
  monthNumber Int
  dayNumber   Int
  description String?

  riteVersionId Int
  riteVersion   RiteVersion    @relation(fields: [riteVersionId], references: [id])
  localeId      Int
  locale        CalendarLocale @relation(fields: [localeId], references: [id])
  rankId        Int
  rank          Rank           @relation(fields: [rankId], references: [id])

  // If fixed feast WERE to be transferred due to a conflict this field would be
  // set to point at the originally schedulled feast day. The resolved will follow 
  // this link to compute whether or not the feast WAS ACTUALLY translated
  // Fixed --> Fixed: eg. Immaculate Conception (Dec 8 → Dec 9)
  rescheduledFromId Int?
  rescheduledFrom   FixedFeast?  @relation("FixedRescheduledLink", fields: [rescheduledFromId], references: [id])
  rescheduledTo     FixedFeast[] @relation("FixedRescheduledLink")

  // Optional cross-type link if a fixed feast transfers to a movableFeast definition
  // Fixed --> Movable eg. Annunciation (Mar 25 → Mon after 2nd Sun of Easter) 
  rescheduledToMovableId    Int?
  rescheduledToMovable      MovableFeast?  @relation("RescheduleToMovable", fields: [rescheduledToMovableId], references: [id])
  rescheduledMoveableFeasts MovableFeast[] @relation("RescheduledToFixed")

  horae                  Hora[]
  missae                 Missa[]
  conflictResolutionRule ConflictResolutionRule[]

  @@unique([key, riteVersionId])
}

model Season {
  id          Int     @id @default(autoincrement())
  key         String // e.g., "Quadragesimae"
  name        String
  color       String? // liturgical color (e.g., "violet")
  description String?

  riteVersionId Int
  riteVersion   RiteVersion @relation(fields: [riteVersionId], references: [id])

  seasonalDay SeasonalDay[]

  @@unique([key, riteVersionId])
}

model SeasonalDay {
  id          Int     @id @default(autoincrement())
  key         String  @unique
  yearNumber  Int
  weekNumber  Int
  dayNumber   Int
  description String?

  riteVersionId Int
  riteVersion   RiteVersion @relation(fields: [riteVersionId], references: [id])
  rankId        Int
  rank          Rank        @relation(fields: [rankId], references: [id])
  seasonId      Int
  season        Season      @relation(fields: [seasonId], references: [id])

  horae  Hora[]
  missae Missa[]

  @@unique([key, riteVersionId])
}

/**
 * ================================================================
 * UNIVERSAL TEXT CORPUS
 * ================================================================
 */

model TextSource {
  id          Int     @id @default(autoincrement())
  code        String  @unique // "VULG", "AUG_SERM", etc.
  title       String
  author      String?
  language    String // ISO code: "la", "en", etc.
  category    String? // "Scripture", "Patristic", "Conciliar", etc.
  description String?

  sections TextSection[] // every source has ≥1 section
  TextUnit TextUnit[]
  RefBlock RefBlock[]
}

model TextSection {
  id           Int        @id @default(autoincrement())
  textSourceId Int
  textSource   TextSource @relation(fields: [textSourceId], references: [id])

  title    String
  code     String? // "GEN", "JOH", "MAIN", etc.
  order    Int? // canonical order within source
  parentId Int?
  parent   TextSection?  @relation("TextSectionParent", fields: [parentId], references: [id])
  children TextSection[] @relation("TextSectionParent")

  units TextUnit[]

  @@unique([textSourceId, code])
  @@index([textSourceId, order])
}

model TextUnit {
  id           Int         @id @default(autoincrement())
  textSourceId Int
  textSource   TextSource  @relation(fields: [textSourceId], references: [id])
  sectionId    Int
  section      TextSection @relation(fields: [sectionId], references: [id])

  sequence       Int // stable monotonic order
  label          String? // "John 3:16", "§12", etc.
  text           String
  refExternal    String? // optional external URI or key
  startRefBlocks RefBlock[] @relation("Start")
  endRefBlocks   RefBlock[] @relation("End")

  @@unique([sectionId, sequence])
  @@index([textSourceId, sectionId, sequence])
}

/**
 * ================================================================
 * CHANT SOURCES / USAGE (aligned to GregoBase)
 * ================================================================
 */

model ChantSource {
  id    Int    @id @default(autoincrement())
  code  String @unique // e.g. "AR1949", "AM1934", "GR1908"
  title String // e.g. "Antiphonale Romanum"
  year  Int // publication year 

  // Helpful bibliographic bits (keep both; see explanation below)
  editor    String? // editor / monastic house / responsible party
  publisher String? // publishing house / imprint

  gabcSources GabcSource[]
}

model ChantUsage {
  id          Int          @id @default(autoincrement())
  key         String       @unique // exactly GregoBase “by usage”, e.g. "Antiphona"
  label       String // display label (same as key or localized)
  gabcSources GabcSource[]
}

model GabcSource {
  id   Int    @id @default(autoincrement())
  name String // chant title as printed in edition
  mode String // I–VIII, "per.", etc.
  gabc String // full GABC notation text

  chantSourceId Int
  chantSource   ChantSource @relation(fields: [chantSourceId], references: [id])
  chantUsageId  Int
  chantUsage    ChantUsage  @relation(fields: [chantUsageId], references: [id])

  textBlock      TextBlock?    @relation(fields: [textBlockId], references: [id])
  textBlockId    Int?
  chantBlock     ChantBlock?   @relation(fields: [chantBlockId], references: [id])
  chantBlockId   Int?
  responsePart   ResponsePart? @relation(fields: [responsePartId], references: [id])
  responsePartId Int?

  @@index([chantSourceId])
  @@index([chantUsageId])
}

/**
 * ================================================================
 * LITURGICAL BUILDING BLOCKS
 * ================================================================
 */

model ActusLiturgicus {
  id     Int    @id @default(autoincrement())
  action String
}

model TextBlock {
  id    Int     @id @default(autoincrement())
  text  String
  title String?

  genusId Int
  genus   TextBlockGenus @relation(fields: [genusId], references: [id])

  parentId Int?
  parent   TextBlock? @relation("TextBlockLineage", fields: [parentId], references: [id])

  children     TextBlock[]  @relation("TextBlockLineage")
  gabcVariants GabcSource[] // optional, for sung versions
}

model TextBlockGenus {
  id          Int    @id @default(autoincrement())
  name        String // e.g. "Collecta", "Postcommunio"
  description String

  textBlocks TextBlock[]
}

model RefBlock {
  id       Int     @id @default(autoincrement())
  title    String?
  seqStart Int // cached startUnit.sequence
  seqEnd   Int // cached endUnit.sequence

  refBlockGenusId Int
  refBlockGenus   RefBlockGenus @relation(fields: [refBlockGenusId], references: [id])
  textSourceId    Int
  textSource      TextSource    @relation(fields: [textSourceId], references: [id])
  parentId        Int?
  parent          RefBlock?     @relation("RefBlockLineage", fields: [parentId], references: [id])

  startUnitId Int
  startUnit   TextUnit @relation("Start", fields: [startUnitId], references: [id])
  endUnitId   Int
  endUnit     TextUnit @relation("End", fields: [endUnitId], references: [id])

  children     RefBlock[]  @relation("RefBlockLineage")
  ChantBlock   ChantBlock? @relation(fields: [chantBlockId], references: [id])
  chantBlockId Int?
}

model RefBlockGenus {
  id          Int    @id @default(autoincrement())
  name        String // e.g. "Psalm", "Reading"
  description String

  refBlocks RefBlock[]
}

model ChantBlock {
  id    Int     @id @default(autoincrement())
  title String
  text  String
  tone  String? // e.g. "VIII G", "IV a", "peregrinus", optional for non-psalmodic chants

  chantBlockGenusId Int
  chantBlockGenus   ChantBlockGenus @relation(fields: [chantBlockGenusId], references: [id])
  parentId          Int?
  parent            ChantBlock?     @relation("ChantBlockLineage", fields: [parentId], references: [id])

  children     ChantBlock[] @relation("ChantBlockLineage")
  // Associated chant variants BY SOURCE, not usage. 
  // This list will contain versions of a particular antiphon across multiple chant sources
  // ie. feria II in Advent in Antiphonale Romanum 1949, Monasticum etc...
  // This list WILL NOT contain versions of a particular antiphon as a related to liturgical function
  // ie. NOT A LIST LIKE THIS: feria II in Advent, feria II in lent, feria II in post pentecost etc
  gabcVariants GabcSource[]
  RefBlock     RefBlock[]
}

model ChantBlockGenus {
  id          Int    @id @default(autoincrement())
  name        String // e.g. "Psalm", "Reading"
  description String

  chantBlocks ChantBlock[]
}

model ResponseSequence {
  id          Int                  @id @default(autoincrement())
  title       String
  description String?
  kind        ResponseSequenceKind @default(OTHER)

  parentId Int?
  parent   ResponseSequence? @relation("ResponseSequenceLineage", fields: [parentId], references: [id])

  children ResponseSequence[] @relation("ResponseSequenceLineage")
  parts    ResponsePart[]
}

enum ResponseSequenceKind {
  RESPONSORY
  VERSICLE
  BENEDICTION
  DISMISSAL
  OTHER
}

model ResponsePart {
  id                 Int              @id @default(autoincrement())
  responseSequenceId Int
  responseSequence   ResponseSequence @relation(fields: [responseSequenceId], references: [id])

  order        Int
  label        String? // e.g. "V.", "R.", "R’", "Chorus", "Amen", "Officiant"
  text         String
  gabcVariants GabcSource[]
}

enum BlockTable {
  ACTUSLITURGICUS
  TEXTBLOCK
  REFBLOCK
  CHANTBLOCK
  RESPONSESEQUENCE
}

/**
 * ================================================================
 * HORA STRUCTURE
 * ================================================================
 */
model Hora {
  id          Int     @id @default(autoincrement())
  name        String
  description String?

  // Link Hora to calendar entities
  fixedFeastId   Int?
  fixedFeast     FixedFeast?   @relation(fields: [fixedFeastId], references: [id])
  movableFeastId Int?
  movableFeast   MovableFeast? @relation(fields: [movableFeastId], references: [id])
  seasonalDayId  Int?
  seasonalDay    SeasonalDay?  @relation(fields: [seasonalDayId], references: [id])

  elements HoraElement[] // ordered components of the Hour
}

model HoraElement {
  id     Int  @id @default(autoincrement())
  horaId Int
  hora   Hora @relation(fields: [horaId], references: [id])

  order Int // order of appearance within the Hour

  // The polymorphic reference
  blockType BlockTable // identifies which table the element points to
  blockId   Int // ID in that table
}

/**
 * ================================================================
 * MISSAL STRUCTURE
 * ================================================================
 */
model Missa {
  id          Int     @id @default(autoincrement())
  name        String
  description String?

  fixedFeastId   Int?
  fixedFeast     FixedFeast?   @relation(fields: [fixedFeastId], references: [id])
  movableFeastId Int?
  movableFeast   MovableFeast? @relation(fields: [movableFeastId], references: [id])
  seasonalDayId  Int?
  seasonalDay    SeasonalDay?  @relation(fields: [seasonalDayId], references: [id])

  elements MissaElement[] // ordered components of the Mass
}

model MissaElement {
  id      Int   @id @default(autoincrement())
  missaId Int
  missa   Missa @relation(fields: [missaId], references: [id])

  order Int // order of appearance within the Mass

  blockType BlockTable // identifies which table the element points to
  blockId   Int // ID in that table
}
